#!/usr/bin/env python3
# coding: utf-8
# @File Name: lrcplayer.py
# @Author: Joshua Liu
# @Email: liuchaozhenyu@gmail.com
# @Create Date: 2017-08-03 10:08:10
# @Last Modified: 2017-08-03 20:08:05
# @Description:

import os
from abc import ABCMeta, abstractmethod

import logging

from threading import Event
import asyncio

import requests
from urllib.parse import quote

import difflib
import re
import json
from lxml import etree

import math
import hashlib

import curses

import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-debug', '--debug', help='debug', action='store_true')
parser.add_argument('-log', '--log', help='logfile save path', action='store')
parser.add_argument('--lyrics-dir', help='lyrics dir', action='store')
parser.add_argument('--disable-download', help='disable download', action='store')
args = parser.parse_args()



DEBUG = args.debug
if DEBUG:
    from mem_top import mem_top

CMUS_LRC_HOME = os.path.expanduser('~') + '/.cmus/lyrics/'
LOGFILE = os.path.expanduser('~') + '/.cmus/cmus-lrc.log'
if args.log is not None:
    LOGFILE = os.path.normpath(os.path.abspath(args.log))
if args.lyrics_dir is not None:
    CMUS_LRC_HOME = os.path.normpath(os.path.abspath(args.lyrics_dir))
DISABLE_DOWNLOAD = args.disable_download



def configure_logging():
    f = logging.FileHandler(LOGFILE, 'w')
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG if DEBUG else logging.INFO)
    logger.addHandler(f)
    if DEBUG:
        logging.debug(mem_top())


class LrcParser(object):

    def parse(self, path):
        try:
            with open(path, 'r') as f:
                lines = f.readlines()
        except:
            return {}

        reLyric = re.compile(r'(\[\d+:\d+(\.\d+)?\])')
        lyrics = self.parseLines(lines, reLyric)

        return lyrics

    def parseLines(self, lines, reLyric):
        lyrics = {}
        for line in lines:
            line = line.strip()
            matchs = re.findall(reLyric, line)
            value = re.sub(reLyric, '', line)
            for match in matchs:
                linetime = self.getTime(match[0])
                while linetime in lyrics.keys():
                    linetime = linetime + 1
                lyrics[linetime] = value

        return sorted(lyrics.items(), key=lambda i: i[0])


    def getTime(self, match):
        n = re.findall('(\d+)', match)

        minutes = int(n[0])
        seconds = int(n[1])
        miliseconds = 0

        if len(n) == 3:
            miliseconds = int(n[2]) * math.pow(10, 3-len(n[2]))

        return (minutes * 60 + seconds) * 1000 + miliseconds


class CmusInfo(object):

    def getInfo(self):
        text = os.popen('cmus-remote -Q').read()
        duration, position, title, artist, album = self.parse(text)
        data = {'duration': duration, 'position': position, 'title': title, 'artist': artist, 'album': album}
        return data


    def parse(self, text):
        position = 0
        duration = 0
        album = ''
        artist = ''
        title = ''

        lines = text.split('\n')
        for line in lines:
            if 'position' in line:
                position = int(line.split(' ')[1])
            elif 'tag artist' in line:
                artist = line.replace('tag artist ', '').replace('/', '-')
            elif 'tag album' in line:
                album = line.replace('tag album ', '').replace('/', '-')
            elif 'tag title' in line:
                title = line.replace('tag title ', '').replace('/', '-')
            elif 'duration' in line:
                duration = int(line.split(' ')[1])

        return duration, position, title, artist, album



class LrcDownloader:
    __metaclass__ = ABCMeta

    TITLE_BASE_VAL = 3
    DURATION_BASE_VAL = 5
    ARTIST_BASE_VAL = 1

    @abstractmethod
    def search(self, title):
        pass

    def match(self, downloaderSongList, targetPlayerSong):
        matchSong = None
        matchVal = 0
        for song in downloaderSongList:
            titleVal = difflib.SequenceMatcher(None, song['title'], targetPlayerSong['title']).quick_ratio()
            titleVal = titleVal * self.TITLE_BASE_VAL

            dtVal = math.pow((targetPlayerSong['duration']-abs((song['duration']//1000)-targetPlayerSong['duration']))/targetPlayerSong['duration'], 3) * self.DURATION_BASE_VAL

            arVal = 0
            if 'ar' in song.keys() and song['ar'] is not None:
                for ar in song['ar']:
                    arVal = arVal + difflib.SequenceMatcher(None, ar['name'], targetPlayerSong['artist']).quick_ratio() * self.ARTIST_BASE_VAL

            tempMatchVal = titleVal + dtVal + arVal

            if tempMatchVal > matchVal:
                matchSong = song
                matchVal = tempMatchVal
        return {
            'song': matchSong,
            'value': matchVal
        }

    @abstractmethod
    def getLyric(self, downloaderSong):
        pass


class XiamiLrcDownloader(LrcDownloader):

    SEARCH_URL = 'https://www.xiami.com/list?scene=search&type=song&query='
    #LYRIC_URL = 'https://www.xiami.com/api/lyric/getSongLyrics?_q='
    LYRIC_URL = 'https://www.xiami.com/api/song/initialize?_q='

    def genSPram(self, xmSgTk, apiPath, queryStr):
        data = '{}_xmMain_{}_{}'.format(xmSgTk.split('_')[0], apiPath, queryStr)
        return hashlib.md5(data.encode('utf8')).hexdigest()

    def search(self, title):
        url = '{}{{"searchKey":"{}"}}'.format(self.SEARCH_URL, quote(title, 'utf-8'))
        logging.info(url)
        r = requests.get(url)
        htmlEtree = etree.HTML(r.text)
        songsEle = htmlEtree.xpath('//*[@id="app"]/div/div[2]/div[1]/div[2]/div/table/tbody/tr')
        songs = []
        cookies = requests.utils.dict_from_cookiejar(r.cookies)
        for ele in songsEle:
            songTitle = ''.join(ele.xpath('.//*[@class="song-name em"]/a//text()'))
            songUrl = ''.join(ele.xpath('.//*[@class="song-name em"]/a/@href'))
            artist = ''.join(ele.xpath('.//*[@class="singers COMPACT"]/a//text()'))
            album = ''.join(ele.xpath('.//*[@class="album"]/a//text()'))
            duration = ''.join(ele.xpath('td[5]/div/span/text()'))
            if len(duration)>0:
                duration = duration.split(':')
                duration = int(duration[0]) * 60 + int(duration[1])
            else:
                duration = None
            song = {
                'title': songTitle,
                'url': songUrl,
                'artist': artist,
                'album': album,
                'duration': duration,
                'cookies': cookies
            }
            if len(songTitle)>0 and len(artist)>0 and len(album)>0 and duration is not None:
                songs.append(song)

        logging.info(json.dumps(songs))
        return songs

    def getLyric(self, downloaderSong):
        cookies=downloaderSong['cookies']
        songId = re.findall('/([^/]*)$', downloaderSong['url'])[0]
        payLoad = {
            'songId': songId
        }
        #apiPath = '/api/lyric/getSongLyrics'
        apiPath = '/api/song/initialize'
        payLoad = {
            'songId': songId
        }

        xmSgTk = cookies['xm_sg_tk']
        sPram = self.genSPram(xmSgTk, apiPath, json.dumps(payLoad))
        url = '{}{}&_s={}'.format(self.LYRIC_URL, json.dumps(payLoad), sPram)
        logging.info(url)
        r = requests.get(url, cookies=cookies)
        data = r.json()
        logging.info(json.dumps(data))
        if data['code'] == 'SUCCESS':
            lyrics = data['result']['data']['songLyric']
            for lyric in lyrics:
                if lyric['type'] == 2:
                    return lyric['content']
        return ''


class NeteaseLrcDownloader(LrcDownloader):

    SEARCH_API = 'https://api.imjad.cn/cloudmusic/?type=search&search_type=1&s='
    LYRIC_API = 'https://api.imjad.cn/cloudmusic/?type=lyric&id='


    def search(self, title):
        url = '{}{}'.format(self.SEARCH_API, quote(title, 'utf-8'))
        logging.info(url)
        r = requests.get(url)
        logging.info(r.text)
        ret = r.json()
        if ret['code'] == 200:
            if 'result' in ret.keys() and 'songs' in ret['result'].keys():
                songs = ret['result']['songs']
                for song in songs:
                    song['title'] = song['name']
                    song['duration'] = song['dt']
                return songs
        return []

    def getLyric(self, song):
        songId = song['id']
        url = '{}{}'.format(self.LYRIC_API, songId)
        r = requests.get(url)
        logging.info(r.text)
        ret = r.json()
        if ret['code'] == 200 and 'lrc' in ret.keys() and ret['lrc']['lyric'] is not None:
            return ret['lrc']['lyric']
        return ''



class Player:
    def __init__(self):

        self.cmusInfo = CmusInfo()
        self.downloader = {
            'netease': NeteaseLrcDownloader(),
            'xiami': XiamiLrcDownloader()
        }
        self.lrcParser = LrcParser()

        self.lyrics = None
        self.current = 0

        self.song = {}
        self.data = None
        self.playLyricFilePath = None

        self.notifyevent = Event()

        self.win = None
        curses.wrapper(self.run)

    def genLyricFilePath(self, songInfo):
        lyricFileName = songInfo['artist'] + ' - ' + songInfo['title'] + '.lrc'
        lyricFilePath = os.path.join(CMUS_LRC_HOME, lyricFileName)
        return lyricFilePath


    def queryLrc(self, song, download):
        if not os.path.isdir(CMUS_LRC_HOME):
            os.makedirs(CMUS_LRC_HOME)
        self.playLyricFilePath = self.genLyricFilePath(song)
        if os.path.isfile(self.playLyricFilePath):
            return self.lrcParser.parse(self.playLyricFilePath)
        else:
            if download:
                if self.downloadLrc(song):
                    return self.lrcParser.parse(self.playLyricFilePath)
            return {}

    def downloadLrc(self, songInfo):
        bestMatchData = None
        for key in self.downloader.keys():
            downloader = self.downloader[key]
            songList = downloader.search(songInfo['title'])
            matchData = downloader.match(songList, self.song)
            logging.info(matchData)
            if matchData['song'] is None:
                continue
            lyric = downloader.getLyric(matchData['song'])
            if len(lyric) != 0 and (bestMatchData is None or matchData['value']>bestMatchData['value']):
                bestMatchData = matchData
                bestMatchData['type'] = key
                bestMatchData['lyric'] = lyric
        logging.info(bestMatchData)
        if bestMatchData == None:
            return False
        with open(self.genLyricFilePath(songInfo), 'w') as f:
            f.write(bestMatchData['lyric'])
            f.close()
            return True

        return False


    @asyncio.coroutine
    def getLyrics(self):
        data = self.data
        if data['title']:
            #logging.info('playing %s' % data['title'])
            if DEBUG:
                logging.debug(mem_top())
            download = False
            if 'title' not in self.song.keys() or self.song['title'] != self.data['title']:
                self.song = {'title': self.data['title'], 'artist': self.data['artist'], 'duration': self.data['duration']}
                download = True
            self.lyrics = self.queryLrc(self.song, (not DISABLE_DOWNLOAD) and download)

    def query_curline(self):
        data = self.data
        if not self._compare_song(data):
            self.lyrics = None

        if not self.lyrics or len(self.lyrics) == 0:
            return -1
        for i, (k, _) in enumerate(self.lyrics):
            if k >= data['position'] * 1000:
                return i - 1 if i - 1 >= 0 else 0
        return len(self.lyrics) - 1


    def _compare_song(self, data):
        if 'title' in data and 'title' in self.song and 'artist' in data and 'artist' in self.song:
            if data['title'] == self.song['title'] and data['artist'] == self.song['artist']:
                return True
            else:
                return False
        return False




    def run(self, stdscr):
        # 使用系统默认的配色
        curses.use_default_colors()
        # 指定当前行的配色。-1: 代表无背景色
        curses.init_pair(6, curses.COLOR_CYAN, -1)
        # 获取当前 window 的最大宽高（以显示字节为单位）
        self.win_maxyx = stdscr.getmaxyx()
        self.stdscr = stdscr
        # set cursor invisible
        curses.curs_set(0)
        curses.noecho()
        self.win = curses.newpad(self.win_maxyx[0], 16383)
        #self.win = stdscr
        self.scroll(self.win, 0) # 从0行呈现

        # 使用 event.wait() 来产生 time tick 任务，每 0.5s 循环一次
        while not self.notifyevent.wait(0.5):
            self.win_maxyx = stdscr.getmaxyx()
            #curses.resizeterm(self.win_maxyx[0], 16383)
            #self.win = curses.newpad(self.win_maxyx[0], 16383)
            self.win.resize(self.win_maxyx[0], 16383)
            data = self.cmusInfo.getInfo()
            #if self.data is not None and data['position'] == self.data['position']:
            #    continue
            self.data = data
            cur = self.query_curline()
            if (-1 == cur):
                self.showinfo({'title': self.data['title'], 'artist': self.data['artist']})
                asyncio.run(self.getLyrics())
            else:
                self.scroll(self.win, cur)


    def showinfo(self, song):
        if 'title' in song:
            title = song['title'].strip()
        else:
            title = 'Unknown song'
        if 'artist' in song:
            artist = song['artist'].strip()
        else:
            artist = 'Unknown artist'
        wt = (len(title) + len(title.encode()))//2
        wa = (len(artist) + len(artist.encode()))//2
        h, w = self.win_maxyx
        xt = (w-wt)//2 if w-wt>=0 else 0
        xa = (w-wa)//2 if w-wa>=0 else 0

        #try:
        self.win.clear()
        self.win.addstr(h//2-1, xt, title)
        self.win.addstr(h//2, xa, artist)
        self.win.refresh(0, 0, 0, 0, h-1, w-1)
        #except Exception as e:
        #    pass



    def scroll(self, win, cur):
        '''
        @param cur: 当前播放的行数，相对于 self.lyrics
        '''
        #if cur == self.current and cur != 0:
        #    return
        if not self.lyrics:
            return

        if cur < len(self.lyrics) and cur >= 0:
            self.current = cur
        else:
            return

        win.clear()
        h, w = self.win_maxyx
        begin = self.current - int(h * 0.4)

        # try:
        for i in range(0, h):
            if i + begin < 0 or i + begin > len(self.lyrics) - 1:
                win.addstr(i, 0, '')
            else:
                k, v = self.lyrics[i + begin]
                v = v.strip()
                lw = (len(v) + len(v.encode()))//2
                x = (w-lw)//2 if w-lw>=0 else 0
                ls = len(v) if len(v) <= w else w
                attr = 0
                if i + begin == self.current:
                    attr = curses.color_pair(6) | curses.A_BOLD
                win.addnstr(i, x, v[0:ls], w-1, attr)
                win.clrtoeol()
                win.clearok(1)
        win.refresh(0, 0, 0, 0, h-1, w-1)
        # except Exception as e:
            # win.clear()
            # x = (w-len(str(e)))//2 if w-len(str(e)) >= 0 else 0
            # l = len(str(e)) if len(str(e)) <= w else w
            # win.addstr(h//2, x, str(e)[0:l-1])
            # win.refresh()


if __name__ == '__main__':
    configure_logging()
    player = Player()

