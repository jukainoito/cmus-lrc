#!/usr/bin/env python3
# coding: utf-8
# @File Name: lrcplayer.py
# @Author: Joshua Liu
# @Email: liuchaozhenyu@gmail.com
# @Create Date: 2017-08-03 10:08:10
# @Last Modified: 2017-08-03 20:08:05
# @Description:
import asyncio
import re
import os
import json
import curses
import logging
from threading import Event

import requests
from urllib.parse import quote
import difflib

import math

import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-debug", "--debug", help="debug", action="store_true")
parser.add_argument("-log", "--log", help="logfile save path", action="store")
parser.add_argument("--lyrics-dir", help="lyrics dir", action="store")
args = parser.parse_args()



DEBUG = args.debug
if DEBUG:
    from mem_top import mem_top

CMUS_LRC_HOME = os.path.expanduser('~') + '/.cmus/lyrics/'
LOGFILE = os.path.expanduser('~') + '/.cmus/cmus-lrc.log'
if args.log is not None:
    LOGFILE = os.path.normpath(os.path.abspath(args.log))
if args.lyrics_dir is not None:
    CMUS_LRC_HOME = os.path.normpath(os.path.abspath(args.lyrics_dir))


def configure_logging():
    f = logging.FileHandler(LOGFILE, 'w')
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG if DEBUG else logging.INFO)
    logger.addHandler(f)
    if DEBUG:
        logging.debug(mem_top())


def parse(path):
    try:
        with open(path, 'r') as f:
            lines = f.readlines()
    except:
        return {}

    re_lyric = re.compile(r'\[\d\d:\d\d.\d{2,3}\]')
    lyrics = parse_lines(lines, re_lyric)
    if len(lyrics) == 0:
        re_lyric = re.compile(r'\[\d\d:\d\d]')
        lyrics = parse_lines(lines, re_lyric)

    return lyrics


def parse_lines(lines, re_lyric):
    lyrics = {}
    for line in lines:
        line = line.strip()
        matchs = re.findall(re_lyric, line)
        value = re.sub(re_lyric, '', line)
        for match in matchs:
            lyrics[_get_time(match)] = value

    return sorted(lyrics.items(), key=lambda i: i[0])


def _get_time(match):
    if len(match) > 7:
        minutes = int(match[1:3])
        seconds = int(match[4:6])
        miliseconds = int(match[7:9])
    else:
        minutes = int(match[1:3])
        seconds = int(match[4:6])
        miliseconds = 0
    return minutes * 60 + seconds + miliseconds / 100.0




class NeteaseLrcDownloader(object):

    SEARCH_API = 'https://api.imjad.cn/cloudmusic/?type=search&search_type=1&s='
    LYRIC_API = 'https://api.imjad.cn/cloudmusic/?type=lyric&id='

    def __init__(self):
        pass

    def search(self, title):
        url = '{}{}'.format(self.SEARCH_API, quote(title, 'utf-8'))
        logging.info(url)
        r = requests.get(url)
        logging.info(r.text)
        ret = r.json()
        if ret['code'] == 200:
            return ret['result']['songs']
        return []

    def getLyric(self, songId):
        url = '{}{}'.format(self.LYRIC_API, songId)
        r = requests.get(url)
        logging.info(r.text)
        ret = r.json()
        if ret['code'] == 200 and 'lrc' in ret.keys() and ret['lrc']['lyric'] is not None:
            return ret['lrc']['lyric']
        return ""


class Player:
    def __init__(self):
        self.lyrics = None
        self.current = 0

        self.song = {}
        self.data = None
        self.playLyricFilePath = None

        self.downloader = {
            'netease': NeteaseLrcDownloader()
        }

        self.notifyevent = Event()

        self.win = None
        curses.wrapper(self.run)

    def genLyricFilePath(self, songInfo):
        lyricFileName = songInfo['artist'] + ' - ' + songInfo['title'] + '.lrc'
        lyricFilePath = os.path.join(CMUS_LRC_HOME, lyricFileName)
        return lyricFilePath


    def query_lrc(self, song, download):
        if not os.path.isdir(CMUS_LRC_HOME):
            os.makedirs(CMUS_LRC_HOME)
        self.playLyricFilePath = self.genLyricFilePath(song)
        if os.path.isfile(self.playLyricFilePath):
            return parse(self.playLyricFilePath)
        else:
            if download:
                if self.downloadLrc(song):
                    return parse(self.playLyricFilePath)
            return {}

    def downloadLrc(self, songInfo):
        downloader = self.downloader['netease']
        songList = downloader.search(songInfo['title'])
        matchSong = None
        matchVal = 0
        for song in songList:
            titleVal = difflib.SequenceMatcher(None, song['name'], songInfo['title']).quick_ratio()
            titleVal = titleVal * 3

            dtVal = math.pow((songInfo['duration']-abs((song['dt']//1000)-songInfo['duration']))/songInfo['duration'], 3) * 5

            arVal = 0
            if 'ar' in song.keys() and song['ar'] is not None:
                for ar in song['ar']:
                    arVal = arVal + difflib.SequenceMatcher(None, ar['name'], songInfo['artist']).quick_ratio()

            tempMatchVal = titleVal + dtVal + arVal

            if tempMatchVal > matchVal:
                matchSong = song
                matchVal = tempMatchVal
        lyric = downloader.getLyric(matchSong['id'])
        with open(self.genLyricFilePath(songInfo), 'w') as f:
            f.write(lyric)
            f.close()
            return True

        return False


    @asyncio.coroutine
    def _get_lyrics(self):
        data = self.data
        if data['title']:
            #logging.info('playing %s' % data['title'])
            if DEBUG:
                logging.debug(mem_top())
            download = False
            if 'title' not in self.song.keys() or self.song['title'] != self.data['title']:
                self.song = {'title': self.data['title'], 'artist': self.data['artist'], 'duration': self.data['duration']}
                download = True
            self.lyrics = self.query_lrc(self.song, download)

    def query_curline(self):
        data = self.data
        if not self._compare_song(data):
            self.lyrics = None

        if not self.lyrics or len(self.lyrics) == 0:
            return -1
        for i, (k, _) in enumerate(self.lyrics):
            if k >= data['position']:
                return i - 1 if i - 1 >= 0 else 0
        return len(self.lyrics) - 1


    def _compare_song(self, data):
        if 'title' in data and 'title' in self.song and 'artist' in data and 'artist' in self.song:
            if data['title'] == self.song['title'] and data['artist'] == self.song['artist']:
                return True
            else:
                return False
        return False


    def _get_cmus_info(self):
        text = os.popen('cmus-remote -Q').read()
        duration, position, title, artist, album = self._parse_cmus(text)
        data = {'duration': duration, 'position': position, 'title': title, 'artist': artist, 'album': album}
        return data


    def _parse_cmus(self, text):
        '''
        status playing
        '''
        position = 0
        duration = 0
        album = ''
        artist = ''
        title = ''
        lines = text.split('\n')
        for line in lines:
            if 'position' in line:
                position = int(line.split(' ')[1])
            elif 'tag artist' in line:
                artist = line.replace('tag artist ', '').replace('/', '-')
            elif 'tag album' in line:
                album = line.replace('tag album ', '').replace('/', '-')
            elif 'tag title' in line:
                title = line.replace('tag title ', '').replace('/', '-')
            elif 'duration' in line:
                duration = int(line.split(' ')[1])

        return duration, position, title, artist, album


    def run(self, stdscr):
        # 使用系统默认的配色
        curses.use_default_colors()
        # 指定当前行的配色。-1: 代表无背景色
        curses.init_pair(6, curses.COLOR_CYAN, -1)
        # 获取当前 window 的最大宽高（以显示字节为单位）
        self.win_maxyx = stdscr.getmaxyx()
        self.stdscr = stdscr
        # set cursor invisible
        curses.curs_set(0)
        curses.noecho()
        self.win = curses.newpad(self.win_maxyx[0], 16383)
        #self.win = stdscr
        self.scroll(self.win, 0) # 从0行呈现

        # 使用 event.wait() 来产生 time tick 任务，每 0.5s 循环一次
        while not self.notifyevent.wait(0.5):
            self.win_maxyx = stdscr.getmaxyx()
            #curses.resizeterm(self.win_maxyx[0], 16383)
            #self.win = curses.newpad(self.win_maxyx[0], 16383)
            self.win.resize(self.win_maxyx[0], 16383)
            data = self._get_cmus_info()
            #if self.data is not None and data['position'] == self.data['position']:
            #    continue
            self.data = data
            cur = self.query_curline()
            if (-1 == cur):
                self.showinfo({'title': self.data['title'], 'artist': self.data['artist']})
                asyncio.run(self._get_lyrics())
            else:
                self.scroll(self.win, cur)


    def showinfo(self, song):
        if 'title' in song:
            title = song['title'].strip()
        else:
            title = 'Unknown song'
        if 'artist' in song:
            artist = song['artist'].strip()
        else:
            artist = 'Unknown artist'
        wt = (len(title) + len(title.encode()))//2
        wa = (len(artist) + len(artist.encode()))//2
        h, w = self.win_maxyx
        xt = (w-wt)//2 if w-wt>=0 else 0
        xa = (w-wa)//2 if w-wa>=0 else 0

        #try:
        self.win.clear()
        self.win.addstr(h//2-1, xt, title)
        self.win.addstr(h//2, xa, artist)
        self.win.refresh(0, 0, 0, 0, h-1, w-1)
        #except Exception as e:
        #    pass



    def scroll(self, win, cur):
        '''
        @param cur: 当前播放的行数，相对于 self.lyrics
        '''
        #if cur == self.current and cur != 0:
        #    return
        if not self.lyrics:
            return

        if cur < len(self.lyrics) and cur >= 0:
            self.current = cur
        else:
            return

        win.clear()
        h, w = self.win_maxyx
        begin = self.current - int(h * 0.4)

        # try:
        for i in range(0, h):
            if i + begin < 0 or i + begin > len(self.lyrics) - 1:
                win.addstr(i, 0, '')
            else:
                k, v = self.lyrics[i + begin]
                v = v.strip()
                lw = (len(v) + len(v.encode()))//2
                x = (w-lw)//2 if w-lw>=0 else 0
                ls = len(v) if len(v) <= w else w
                attr = 0
                if i + begin == self.current:
                    attr = curses.color_pair(6) | curses.A_BOLD
                win.addnstr(i, x, v[0:ls], w-1, attr)
                win.clrtoeol()
                win.clearok(1)
        win.refresh(0, 0, 0, 0, h-1, w-1)
        # except Exception as e:
            # win.clear()
            # x = (w-len(str(e)))//2 if w-len(str(e)) >= 0 else 0
            # l = len(str(e)) if len(str(e)) <= w else w
            # win.addstr(h//2, x, str(e)[0:l-1])
            # win.refresh()


if __name__ == '__main__':
    configure_logging()
    player = Player()

